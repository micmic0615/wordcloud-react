{"ast":null,"code":"/*!\n* wordcloud2.js\n* http://timdream.org/wordcloud2.js/\n*\n* Copyright 2011 - 2013 Tim Chien\n* Released under the MIT license\n*/\n// setImmediate\nif (!window.setImmediate) {\n  window.setImmediate = function setupSetImmediate() {\n    return window.msSetImmediate || window.webkitSetImmediate || window.mozSetImmediate || window.oSetImmediate || function setupSetZeroTimeout() {\n      if (!window.postMessage || !window.addEventListener) {\n        return null;\n      }\n\n      var callbacks = [undefined];\n      var message = 'zero-timeout-message'; // Like setTimeout, but only takes a function argument.  There's\n      // no time argument (always zero) and no arguments (you have to\n      // use a closure).\n\n      var setZeroTimeout = function setZeroTimeout(callback) {\n        var id = callbacks.length;\n        callbacks.push(callback);\n        window.postMessage(message + id.toString(36), '*');\n        return id;\n      };\n\n      window.addEventListener('message', function setZeroTimeoutMessage(evt) {\n        // Skipping checking event source, retarded IE confused this window\n        // object with another in the presence of iframe\n        if (typeof evt.data !== 'string' || evt.data.substr(0, message.length) !== message\n        /* ||\n        evt.source !== window */\n        ) {\n            return;\n          }\n\n        evt.stopImmediatePropagation();\n        var id = parseInt(evt.data.substr(message.length), 36);\n\n        if (!callbacks[id]) {\n          return;\n        }\n\n        callbacks[id]();\n        callbacks[id] = undefined;\n      }, true);\n      /* specify clearImmediate() here since we need the scope */\n\n      window.clearImmediate = function clearZeroTimeout(id) {\n        if (!callbacks[id]) {\n          return;\n        }\n\n        callbacks[id] = undefined;\n      };\n\n      return setZeroTimeout;\n    }() || // fallback\n    function setImmediateFallback(fn) {\n      window.setTimeout(fn, 0);\n    };\n  }();\n}\n\nif (!window.clearImmediate) {\n  window.clearImmediate = function setupClearImmediate() {\n    return window.msClearImmediate || window.webkitClearImmediate || window.mozClearImmediate || window.oClearImmediate || // \"clearZeroTimeout\" is implement on the previous block ||\n    // fallback\n    function clearImmediateFallback(timer) {\n      window.clearTimeout(timer);\n    };\n  }();\n} // Check if WordCloud can run on this browser\n\n\nvar isSupported = function isSupported() {\n  var canvas = document.createElement('canvas');\n\n  if (!canvas || !canvas.getContext) {\n    return false;\n  }\n\n  var ctx = canvas.getContext('2d');\n\n  if (!ctx) {\n    return false;\n  }\n\n  if (!ctx.getImageData) {\n    return false;\n  }\n\n  if (!ctx.fillText) {\n    return false;\n  }\n\n  if (!Array.prototype.some) {\n    return false;\n  }\n\n  if (!Array.prototype.push) {\n    return false;\n  }\n\n  return true;\n}(); // Find out if the browser impose minium font size by\n// drawing small texts on a canvas and measure it's width.\n\n\nvar minFontSize = function getMinFontSize() {\n  if (!isSupported) {\n    return;\n  }\n\n  var ctx = document.createElement('canvas').getContext('2d'); // start from 20\n\n  var size = 20; // two sizes to measure\n\n  var hanWidth, mWidth;\n\n  while (size) {\n    ctx.font = size.toString(10) + 'px sans-serif';\n\n    if (ctx.measureText('\\uFF37').width === hanWidth && ctx.measureText('m').width === mWidth) {\n      return size + 1;\n    }\n\n    hanWidth = ctx.measureText('\\uFF37').width;\n    mWidth = ctx.measureText('m').width;\n    size--;\n  }\n\n  return 0;\n}(); // Based on http://jsfromhell.com/array/shuffle\n\n\nvar shuffleArray = function shuffleArray(arr) {\n  for (var j, x, i = arr.length; i; j = Math.floor(Math.random() * i), x = arr[--i], arr[i] = arr[j], arr[j] = x) {}\n\n  return arr;\n};\n\nvar WordCloud = function WordCloud(elements, options) {\n  if (!isSupported) {\n    return;\n  }\n\n  if (!Array.isArray(elements)) {\n    elements = [elements];\n  }\n\n  elements.forEach(function (el, i) {\n    if (typeof el === 'string') {\n      elements[i] = document.getElementById(el);\n\n      if (!elements[i]) {\n        throw new Error('The element id specified is not found.');\n      }\n    } else if (!el.tagName && !el.appendChild) {\n      throw new Error('You must pass valid HTML elements, or ID of the element.');\n    }\n  });\n  /* Default values to be overwritten by options object */\n\n  var settings = {\n    list: [],\n    frame: null,\n    fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"微軟正黑體\", ' + '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',\n    fontWeight: 'normal',\n    color: 'random-dark',\n    minSize: 0,\n    // 0 to disable\n    weightFactor: 1,\n    clearCanvas: true,\n    backgroundColor: '#fff',\n    // opaque white = rgba(255, 255, 255, 1)\n    gridSize: 8,\n    drawOutOfBound: false,\n    origin: null,\n    drawMask: false,\n    maskColor: 'rgba(255,0,0,0.3)',\n    maskGapWidth: 0.3,\n    wait: 0,\n    abortThreshold: 0,\n    // disabled\n    abort: function noop() {},\n    minRotation: -Math.PI / 2,\n    maxRotation: Math.PI / 2,\n    rotationSteps: 0,\n    shuffle: true,\n    rotateRatio: 0.1,\n    shape: 'circle',\n    ellipticity: 0.65,\n    classes: null,\n    hover: null,\n    click: null\n  };\n\n  if (options) {\n    for (var key in options) {\n      if (key in settings) {\n        settings[key] = options[key];\n      }\n    }\n  }\n  /* Convert weightFactor into a function */\n\n\n  if (typeof settings.weightFactor !== 'function') {\n    var factor = settings.weightFactor;\n\n    settings.weightFactor = function weightFactor(pt) {\n      return pt * factor; //in px\n    };\n  }\n  /* Convert shape into a function */\n\n\n  if (typeof settings.shape !== 'function') {\n    switch (settings.shape) {\n      case 'circle':\n      /* falls through */\n\n      default:\n        // 'circle' is the default and a shortcut in the code loop.\n        settings.shape = 'circle';\n        break;\n\n      case 'cardioid':\n        settings.shape = function shapeCardioid(theta) {\n          return 1 - Math.sin(theta);\n        };\n\n        break;\n\n      /*\n       To work out an X-gon, one has to calculate \"m\",\n      where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))\n      http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28\n      2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29\n       Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))\n      where t' equals to mod(t, 2PI/X);\n       */\n\n      case 'diamond':\n        // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n        // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D\n        // +0+..+2*PI\n        settings.shape = function shapeSquare(theta) {\n          var thetaPrime = theta % (2 * Math.PI / 4);\n          return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));\n        };\n\n        break;\n\n      case 'square':\n        // http://www.wolframalpha.com/input/?i=plot+r+%3D+min(1%2Fabs(cos(t\n        // )),1%2Fabs(sin(t)))),+t+%3D+0+..+2*PI\n        settings.shape = function shapeSquare(theta) {\n          return Math.min(1 / Math.abs(Math.cos(theta)), 1 / Math.abs(Math.sin(theta)));\n        };\n\n        break;\n\n      case 'triangle-forward':\n        // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n        // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29\n        // %29%29%2C+t+%3D+0+..+2*PI\n        settings.shape = function shapeTriangle(theta) {\n          var thetaPrime = theta % (2 * Math.PI / 3);\n          return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n        };\n\n        break;\n\n      case 'triangle':\n      case 'triangle-upright':\n        settings.shape = function shapeTriangle(theta) {\n          var thetaPrime = (theta + Math.PI * 3 / 2) % (2 * Math.PI / 3);\n          return 1 / (Math.cos(thetaPrime) + Math.sqrt(3) * Math.sin(thetaPrime));\n        };\n\n        break;\n\n      case 'pentagon':\n        settings.shape = function shapePentagon(theta) {\n          var thetaPrime = (theta + 0.955) % (2 * Math.PI / 5);\n          return 1 / (Math.cos(thetaPrime) + 0.726543 * Math.sin(thetaPrime));\n        };\n\n        break;\n\n      case 'star':\n        settings.shape = function shapeStar(theta) {\n          var thetaPrime = (theta + 0.955) % (2 * Math.PI / 10);\n\n          if ((theta + 0.955) % (2 * Math.PI / 5) - 2 * Math.PI / 10 >= 0) {\n            return 1 / (Math.cos(2 * Math.PI / 10 - thetaPrime) + 3.07768 * Math.sin(2 * Math.PI / 10 - thetaPrime));\n          } else {\n            return 1 / (Math.cos(thetaPrime) + 3.07768 * Math.sin(thetaPrime));\n          }\n        };\n\n        break;\n    }\n  }\n  /* Make sure gridSize is a whole number and is not smaller than 4px */\n\n\n  settings.gridSize = Math.max(Math.floor(settings.gridSize), 4);\n  /* shorthand */\n\n  var g = settings.gridSize;\n  var maskRectWidth = g - settings.maskGapWidth;\n  /* normalize rotation settings */\n\n  var rotationRange = Math.abs(settings.maxRotation - settings.minRotation);\n  var rotationSteps = Math.abs(Math.floor(settings.rotationSteps));\n  var minRotation = Math.min(settings.maxRotation, settings.minRotation);\n  /* information/object available to all functions, set when start() */\n\n  var grid, // 2d array containing filling information\n  ngx, ngy, // width and height of the grid\n  center, // position of the center of the cloud\n  maxRadius;\n  /* timestamp for measuring each putWord() action */\n\n  var escapeTime;\n  /* function for getting the color of the text */\n\n  var getTextColor;\n\n  function random_hsl_color(min, max) {\n    return 'hsl(' + (Math.random() * 360).toFixed() + ',' + (Math.random() * 30 + 70).toFixed() + '%,' + (Math.random() * (max - min) + min).toFixed() + '%)';\n  }\n\n  switch (settings.color) {\n    case 'random-dark':\n      getTextColor = function getRandomDarkColor() {\n        return random_hsl_color(10, 50);\n      };\n\n      break;\n\n    case 'random-light':\n      getTextColor = function getRandomLightColor() {\n        return random_hsl_color(50, 90);\n      };\n\n      break;\n\n    default:\n      if (typeof settings.color === 'function') {\n        getTextColor = settings.color;\n      }\n\n      break;\n  }\n  /* function for getting the font-weight of the text */\n\n\n  var getTextFontWeight;\n\n  if (typeof settings.fontWeight === 'function') {\n    getTextFontWeight = settings.fontWeight;\n  }\n  /* function for getting the classes of the text */\n\n\n  var getTextClasses = null;\n\n  if (typeof settings.classes === 'function') {\n    getTextClasses = settings.classes;\n  }\n  /* Interactive */\n\n\n  var interactive = false;\n  var infoGrid = [];\n  var hovered;\n\n  var getInfoGridFromMouseTouchEvent = function getInfoGridFromMouseTouchEvent(evt) {\n    var canvas = evt.currentTarget;\n    var rect = canvas.getBoundingClientRect();\n    var clientX;\n    var clientY;\n    /** Detect if touches are available */\n\n    if (evt.touches) {\n      clientX = evt.touches[0].clientX;\n      clientY = evt.touches[0].clientY;\n    } else {\n      clientX = evt.clientX;\n      clientY = evt.clientY;\n    }\n\n    var eventX = clientX - rect.left;\n    var eventY = clientY - rect.top;\n    var x = Math.floor(eventX * (canvas.width / rect.width || 1) / g);\n    var y = Math.floor(eventY * (canvas.height / rect.height || 1) / g);\n    return infoGrid[x][y];\n  };\n\n  var wordcloudhover = function wordcloudhover(evt) {\n    var info = getInfoGridFromMouseTouchEvent(evt);\n\n    if (hovered === info) {\n      return;\n    }\n\n    hovered = info;\n\n    if (!info) {\n      settings.hover(undefined, undefined, evt);\n      return;\n    }\n\n    settings.hover(info.item, info.dimension, evt);\n  };\n\n  var wordcloudclick = function wordcloudclick(evt) {\n    var info = getInfoGridFromMouseTouchEvent(evt);\n\n    if (!info) {\n      return;\n    }\n\n    settings.click(info.item, info.dimension, evt);\n    evt.preventDefault();\n  };\n  /* Get points on the grid for a given radius away from the center */\n\n\n  var pointsAtRadius = [];\n\n  var getPointsAtRadius = function getPointsAtRadius(radius) {\n    if (pointsAtRadius[radius]) {\n      return pointsAtRadius[radius];\n    } // Look for these number of points on each radius\n\n\n    var T = radius * 8; // Getting all the points at this radius\n\n    var t = T;\n    var points = [];\n\n    if (radius === 0) {\n      points.push([center[0], center[1], 0]);\n    }\n\n    while (t--) {\n      // distort the radius to put the cloud in shape\n      var rx = 1;\n\n      if (settings.shape !== 'circle') {\n        rx = settings.shape(t / T * 2 * Math.PI); // 0 to 1\n      } // Push [x, y, t]; t is used solely for getTextColor()\n\n\n      points.push([center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI), center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) * settings.ellipticity, t / T * 2 * Math.PI]);\n    }\n\n    pointsAtRadius[radius] = points;\n    return points;\n  };\n  /* Return true if we had spent too much time */\n\n\n  var exceedTime = function exceedTime() {\n    return settings.abortThreshold > 0 && new Date().getTime() - escapeTime > settings.abortThreshold;\n  };\n  /* Get the deg of rotation according to settings, and luck. */\n\n\n  var getRotateDeg = function getRotateDeg(index) {\n    if (settings.rotateRatio === 0) {\n      return 0;\n    }\n\n    if (settings.shuffle) {\n      if (Math.random() > settings.rotateRatio) {\n        return 0;\n      }\n    } else {\n      if (index % 2) {\n        return 0;\n      }\n    }\n\n    if (rotationRange === 0) {\n      return minRotation;\n    }\n\n    if (rotationSteps > 0) {\n      // Min rotation + zero or more steps * span of one step\n      if (settings.shuffle) {\n        return minRotation + Math.floor(Math.random() * rotationSteps) * rotationRange / (rotationSteps - 1);\n      } else {\n        return minRotation + Math.floor(index % 2 * rotationSteps) * rotationRange / (rotationSteps - 1);\n      }\n    } else {\n      return minRotation + Math.random() * rotationRange;\n    }\n  };\n\n  var getTextInfo = function getTextInfo(word, weight, rotateDeg) {\n    // calculate the acutal font size\n    // fontSize === 0 means weightFactor function wants the text skipped,\n    // and size < minSize means we cannot draw the text.\n    var debug = false;\n    var fontSize = settings.weightFactor(weight);\n\n    if (fontSize <= settings.minSize) {\n      return false;\n    } // Scale factor here is to make sure fillText is not limited by\n    // the minium font size set by browser.\n    // It will always be 1 or 2n.\n\n\n    var mu = 1;\n\n    if (fontSize < minFontSize) {\n      mu = function calculateScaleFactor() {\n        var mu = 2;\n\n        while (mu * fontSize < minFontSize) {\n          mu += 2;\n        }\n\n        return mu;\n      }();\n    } // Get fontWeight that will be used to set fctx.font\n\n\n    var fontWeight;\n\n    if (getTextFontWeight) {\n      fontWeight = getTextFontWeight(word, weight, fontSize);\n    } else {\n      fontWeight = settings.fontWeight;\n    }\n\n    var fcanvas = document.createElement('canvas');\n    var fctx = fcanvas.getContext('2d', {\n      willReadFrequently: true\n    });\n    fctx.font = fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily; // Estimate the dimension of the text with measureText().\n\n    var fw = fctx.measureText(word).width / mu;\n    var fh = Math.max(fontSize * mu, fctx.measureText('m').width, fctx.measureText('\\uFF37').width) / mu; // Create a boundary box that is larger than our estimates,\n    // so text don't get cut of (it sill might)\n\n    var boxWidth = fw + fh * 2;\n    var boxHeight = fh * 3;\n    var fgw = Math.ceil(boxWidth / g);\n    var fgh = Math.ceil(boxHeight / g);\n    boxWidth = fgw * g;\n    boxHeight = fgh * g; // Calculate the proper offsets to make the text centered at\n    // the preferred position.\n    // This is simply half of the width.\n\n    var fillTextOffsetX = -fw / 2; // Instead of moving the box to the exact middle of the preferred\n    // position, for Y-offset we move 0.4 instead, so Latin alphabets look\n    // vertical centered.\n\n    var fillTextOffsetY = -fh * 0.4; // Calculate the actual dimension of the canvas, considering the rotation.\n\n    var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) + boxHeight * Math.abs(Math.cos(rotateDeg))) / g);\n    var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) + boxHeight * Math.abs(Math.sin(rotateDeg))) / g);\n    var width = cgw * g;\n    var height = cgh * g;\n    fcanvas.setAttribute('width', width);\n    fcanvas.setAttribute('height', height);\n\n    if (debug) {\n      // Attach fcanvas to the DOM\n      document.body.appendChild(fcanvas); // Save it's state so that we could restore and draw the grid correctly.\n\n      fctx.save();\n    } // Scale the canvas with |mu|.\n\n\n    fctx.scale(1 / mu, 1 / mu);\n    fctx.translate(width * mu / 2, height * mu / 2);\n    fctx.rotate(-rotateDeg); // Once the width/height is set, ctx info will be reset.\n    // Set it again here.\n\n    fctx.font = fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily; // Fill the text into the fcanvas.\n    // XXX: We cannot because textBaseline = 'top' here because\n    // Firefox and Chrome uses different default line-height for canvas.\n    // Please read https://bugzil.la/737852#c6.\n    // Here, we use textBaseline = 'middle' and draw the text at exactly\n    // 0.5 * fontSize lower.\n\n    fctx.fillStyle = '#000';\n    fctx.textBaseline = 'middle';\n    fctx.fillText(word, fillTextOffsetX * mu, (fillTextOffsetY + fontSize * 0.5) * mu); // Get the pixels of the text\n\n    var imageData = fctx.getImageData(0, 0, width, height).data;\n\n    if (exceedTime()) {\n      return false;\n    }\n\n    if (debug) {\n      // Draw the box of the original estimation\n      fctx.strokeRect(fillTextOffsetX * mu, fillTextOffsetY, fw * mu, fh * mu);\n      fctx.restore();\n    } // Read the pixels and save the information to the occupied array\n\n\n    var occupied = [];\n    var gx = cgw,\n        gy,\n        x,\n        y;\n    var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];\n\n    while (gx--) {\n      gy = cgh;\n\n      while (gy--) {\n        y = g;\n\n        while (y--) {\n          x = g;\n\n          while (x--) {\n            if (imageData[((gy * g + y) * width + (gx * g + x)) * 4 + 3]) {\n              occupied.push([gx, gy]);\n\n              if (gx < bounds[3]) {\n                bounds[3] = gx;\n              }\n\n              if (gx > bounds[1]) {\n                bounds[1] = gx;\n              }\n\n              if (gy < bounds[0]) {\n                bounds[0] = gy;\n              }\n\n              if (gy > bounds[2]) {\n                bounds[2] = gy;\n              }\n\n              if (debug) {\n                fctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n                fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n              }\n\n              break;\n            }\n          }\n        }\n\n        if (debug) {\n          fctx.fillStyle = 'rgba(0, 0, 255, 0.5)';\n          fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n        }\n      }\n    }\n\n    if (debug) {\n      fctx.fillStyle = 'rgba(0, 255, 0, 0.5)';\n      fctx.fillRect(bounds[3] * g, bounds[0] * g, (bounds[1] - bounds[3] + 1) * g, (bounds[2] - bounds[0] + 1) * g);\n    } // Return information needed to create the text on the real canvas\n\n\n    return {\n      mu: mu,\n      occupied: occupied,\n      bounds: bounds,\n      gw: cgw,\n      gh: cgh,\n      fillTextOffsetX: fillTextOffsetX,\n      fillTextOffsetY: fillTextOffsetY,\n      fillTextWidth: fw,\n      fillTextHeight: fh,\n      fontSize: fontSize\n    };\n  };\n  /* Determine if there is room available in the given dimension */\n\n\n  var canFitText = function canFitText(gx, gy, gw, gh, occupied) {\n    // Go through the occupied points,\n    // return false if the space is not available.\n    var i = occupied.length;\n\n    while (i--) {\n      var px = gx + occupied[i][0];\n      var py = gy + occupied[i][1];\n\n      if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n        if (!settings.drawOutOfBound) {\n          return false;\n        }\n\n        continue;\n      }\n\n      if (!grid[px][py]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /* Actually draw the text on the grid */\n\n\n  var drawText = function drawText(gx, gy, info, textInfo, text, weight, distance, theta, rotateDeg, attributes) {\n    var fontSize = info.fontSize;\n    var color;\n\n    if (getTextColor) {\n      color = getTextColor(text, weight, fontSize, distance, theta);\n    } else {\n      color = settings.color;\n    } // get fontWeight that will be used to set ctx.font and font style rule\n\n\n    var fontWeight;\n\n    if (getTextFontWeight) {\n      fontWeight = getTextFontWeight(text, weight, fontSize);\n    } else {\n      fontWeight = settings.fontWeight;\n    }\n\n    var classes;\n\n    if (getTextClasses) {\n      classes = getTextClasses(text, weight, fontSize);\n    } else {\n      classes = settings.classes;\n    }\n\n    var dimension;\n    var bounds = info.bounds;\n    dimension = {\n      x: (gx + bounds[3]) * g,\n      y: (gy + bounds[0]) * g,\n      w: (bounds[1] - bounds[3] + 1) * g,\n      h: (bounds[2] - bounds[0] + 1) * g\n    };\n    elements.forEach(function (el) {\n      if (el.getContext) {\n        var ctx = el.getContext('2d');\n        var mu = info.mu; // Save the current state before messing it\n\n        ctx.save(); // SCALE_TEXT\n\n        var scaleX = info.fillTextWidth / textInfo.fillTextWidth;\n\n        if (rotateDeg !== 0) {\n          ctx.scale(1 / mu, scaleX / mu);\n        } else {\n          ctx.scale(scaleX / mu, 1 / mu);\n        }\n\n        ctx.font = fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n        ctx.fillStyle = color; // Translate the canvas position to the origin coordinate of where\n        // the text should be put.\n\n        var translateX = (gx + info.gw / 2) * g * mu;\n        var translateY = (gy + info.gh / 2) * g * mu;\n        var moveX = scaleX;\n        var adjustX = 0;\n\n        if (moveX !== 1) {\n          moveX = scaleX;\n          adjustX = info.fillTextOffsetX - textInfo.fillTextOffsetX;\n        }\n\n        if (rotateDeg !== 0) {\n          ctx.translate(translateX, translateY / moveX - adjustX);\n          ctx.rotate(-rotateDeg);\n        } else {\n          ctx.translate(translateX / moveX - adjustX, translateY);\n        } // Finally, fill the text.\n        // XXX: We cannot because textBaseline = 'top' here because\n        // Firefox and Chrome uses different default line-height for canvas.\n        // Please read https://bugzil.la/737852#c6.\n        // Here, we use textBaseline = 'middle' and draw the text at exactly\n        // 0.5 * fontSize lower.\n\n\n        ctx.textBaseline = 'middle';\n        ctx.fillText(text, info.fillTextOffsetX * mu, (info.fillTextOffsetY + fontSize * 0.5) * mu); // The below box is always matches how <span>s are positioned\n\n        /* ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,\n          info.fillTextWidth, info.fillTextHeight); */\n        // Restore the state.\n\n        ctx.restore();\n      } else {\n        // drawText on DIV element\n        var span = document.createElement('span');\n        var transformRule = '';\n        transformRule = 'rotate(' + -rotateDeg / Math.PI * 180 + 'deg) ';\n\n        if (info.mu !== 1) {\n          transformRule += 'translateX(-' + info.fillTextWidth / 4 + 'px) ' + 'scale(' + 1 / info.mu + ')';\n        }\n\n        var styleRules = {\n          'position': 'absolute',\n          'display': 'block',\n          'font': fontWeight + ' ' + fontSize * info.mu + 'px ' + settings.fontFamily,\n          'left': (gx + info.gw / 2) * g + info.fillTextOffsetX + 'px',\n          'top': (gy + info.gh / 2) * g + info.fillTextOffsetY + 'px',\n          'width': info.fillTextWidth + 'px',\n          'height': info.fillTextHeight + 'px',\n          'lineHeight': fontSize + 'px',\n          'whiteSpace': 'nowrap',\n          'transform': transformRule,\n          'webkitTransform': transformRule,\n          'msTransform': transformRule,\n          'transformOrigin': '50% 40%',\n          'webkitTransformOrigin': '50% 40%',\n          'msTransformOrigin': '50% 40%'\n        };\n\n        if (color) {\n          styleRules.color = color;\n        }\n\n        span.textContent = text;\n\n        for (var cssProp in styleRules) {\n          span.style[cssProp] = styleRules[cssProp];\n        }\n\n        if (attributes) {\n          for (var attribute in attributes) {\n            span.setAttribute(attribute, attributes[attribute]);\n          }\n        }\n\n        if (classes) {\n          span.className += classes;\n        }\n\n        el.appendChild(span);\n      }\n    });\n  };\n  /* Help function to updateGrid */\n\n\n  var fillGridAt = function fillGridAt(x, y, drawMask, dimension, item) {\n    if (x >= ngx || y >= ngy || x < 0 || y < 0) {\n      return;\n    }\n\n    grid[x][y] = false;\n\n    if (drawMask) {\n      var ctx = elements[0].getContext('2d');\n      ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth);\n    }\n\n    if (interactive) {\n      infoGrid[x][y] = {\n        item: item,\n        dimension: dimension\n      };\n    }\n  };\n  /* Update the filling information of the given space with occupied points.\n      Draw the mask on the canvas if necessary. */\n\n\n  var updateGrid = function updateGrid(gx, gy, gw, gh, info, item) {\n    var occupied = info.occupied;\n    var drawMask = settings.drawMask;\n    var ctx;\n\n    if (drawMask) {\n      ctx = elements[0].getContext('2d');\n      ctx.save();\n      ctx.fillStyle = settings.maskColor;\n    }\n\n    var dimension;\n\n    if (interactive) {\n      var bounds = info.bounds;\n      dimension = {\n        x: (gx + bounds[3]) * g,\n        y: (gy + bounds[0]) * g,\n        w: (bounds[1] - bounds[3] + 1) * g,\n        h: (bounds[2] - bounds[0] + 1) * g\n      };\n    }\n\n    var i = occupied.length;\n\n    while (i--) {\n      var px = gx + occupied[i][0];\n      var py = gy + occupied[i][1];\n\n      if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n        continue;\n      }\n\n      fillGridAt(px, py, drawMask, dimension, item);\n    }\n\n    if (drawMask) {\n      ctx.restore();\n    }\n  };\n  /* putWord() processes each item on the list,\n      calculate it's size and determine it's position, and actually\n      put it on the canvas. */\n\n\n  var putWord = function putWord(params) {\n    var index = params.index,\n        item = params.item,\n        frame = params.frame;\n    var word, text, weight, attributes;\n    var raw = frame || item;\n\n    if (Array.isArray(raw)) {\n      word = raw[0];\n      weight = raw[1];\n      text = item[0];\n    } else {\n      word = raw.word;\n      text = item.word;\n      weight = raw.weight;\n      attributes = raw.attributes;\n    }\n\n    var rotateDeg = getRotateDeg(index); // get info needed to put the text onto the canvas\n\n    var info = getTextInfo(word, weight, rotateDeg);\n    var textInfo = getTextInfo(text, weight, rotateDeg); // not getting the info means we shouldn't be drawing this one.\n\n    if (!info) {\n      return false;\n    }\n\n    if (exceedTime()) {\n      return false;\n    } // If drawOutOfBound is set to false,\n    // skip the loop if we have already know the bounding box of\n    // word is larger than the canvas.\n\n\n    if (!settings.drawOutOfBound) {\n      var bounds = info.bounds;\n\n      if (bounds[1] - bounds[3] + 1 > ngx || bounds[2] - bounds[0] + 1 > ngy) {\n        return false;\n      }\n    } // Determine the position to put the text by\n    // start looking for the nearest points\n\n\n    var r = maxRadius + 1;\n\n    var tryToPutWordAtPoint = function (gxy) {\n      var gx = Math.floor(gxy[0] - info.gw / 2);\n      var gy = Math.floor(gxy[1] - info.gh / 2);\n      var gw = info.gw;\n      var gh = info.gh; // If we cannot fit the text at this position, return false\n      // and go to the next position.\n\n      if (!canFitText(gx, gy, gw, gh, info.occupied)) {\n        return false;\n      } // Actually put the text on the canvas\n\n\n      drawText(gx, gy, info, textInfo, text, weight, maxRadius - r, gxy[2], rotateDeg, attributes); // Mark the spaces on the grid as filled\n\n      updateGrid(gx, gy, gw, gh, info, item); // Return true so some() will stop and also return true.\n\n      return true;\n    };\n\n    while (r--) {\n      var points = getPointsAtRadius(maxRadius - r);\n\n      if (settings.shuffle) {\n        points = [].concat(points);\n        shuffleArray(points);\n      } // Try to fit the words by looking at each point.\n      // array.some() will stop and return true\n      // when putWordAtPoint() returns true.\n      // If all the points returns false, array.some() returns false.\n\n\n      var drawn = points.some(tryToPutWordAtPoint);\n\n      if (drawn) {\n        // leave putWord() and return true\n        return true;\n      }\n    } // we tried all distances but text won't fit, return false\n\n\n    return false;\n  };\n  /* Send DOM event to all elements. Will stop sending event and return\n      if the previous one is canceled (for cancelable events). */\n\n\n  var sendEvent = function sendEvent(type, cancelable, details) {\n    if (cancelable) {\n      return !elements.some(function (el) {\n        var event = new CustomEvent(type, {\n          detail: details || {}\n        });\n        return !el.dispatchEvent(event);\n      }, this);\n    } else {\n      elements.forEach(function (el) {\n        var event = new CustomEvent(type, {\n          detail: details || {}\n        });\n        el.dispatchEvent(event);\n      }, this);\n    }\n  };\n  /* Start drawing on a canvas */\n\n\n  var start = function start() {\n    // For dimensions, clearCanvas etc.,\n    // we only care about the first element.\n    var canvas = elements[0];\n\n    if (canvas.getContext) {\n      ngx = Math.ceil(canvas.width / g);\n      ngy = Math.ceil(canvas.height / g);\n    } else {\n      var rect = canvas.getBoundingClientRect();\n      ngx = Math.ceil(rect.width / g);\n      ngy = Math.ceil(rect.height / g);\n    } // Sending a wordcloudstart event which cause the previous loop to stop.\n    // Do nothing if the event is canceled.\n\n\n    if (!sendEvent('wordcloudstart', true)) {\n      return;\n    } // Determine the center of the word cloud\n\n\n    center = settings.origin ? [settings.origin[0] / g, settings.origin[1] / g] : [ngx / 2, ngy / 2]; // Maxium radius to look for space\n\n    maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));\n    /* Clear the canvas only if the clearCanvas is set,\n        if not, update the grid to the current canvas state */\n\n    grid = [];\n    var gx, gy, i;\n\n    if (!canvas.getContext || settings.clearCanvas) {\n      elements.forEach(function (el) {\n        if (el.getContext) {\n          var ctx = el.getContext('2d');\n          ctx.fillStyle = settings.backgroundColor;\n          ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n          ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n        } else {\n          el.textContent = '';\n          el.style.backgroundColor = settings.backgroundColor;\n          el.style.position = 'relative';\n        }\n      });\n      /* fill the grid with empty state */\n\n      gx = ngx;\n\n      while (gx--) {\n        grid[gx] = [];\n        gy = ngy;\n\n        while (gy--) {\n          grid[gx][gy] = true;\n        }\n      }\n    } else {\n      /* Determine bgPixel by creating\n          another canvas and fill the specified background color. */\n      var bctx = document.createElement('canvas').getContext('2d');\n      bctx.fillStyle = settings.backgroundColor;\n      bctx.fillRect(0, 0, 1, 1);\n      var bgPixel = bctx.getImageData(0, 0, 1, 1).data;\n      /* Read back the pixels of the canvas we got to tell which part of the\n          canvas is empty.\n          (no clearCanvas only works with a canvas, not divs) */\n\n      var imageData = canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data;\n      gx = ngx;\n      var x, y;\n\n      while (gx--) {\n        grid[gx] = [];\n        gy = ngy;\n\n        while (gy--) {\n          y = g;\n\n          singleGridLoop: while (y--) {\n            x = g;\n\n            while (x--) {\n              i = 4;\n\n              while (i--) {\n                if (imageData[((gy * g + y) * ngx * g + (gx * g + x)) * 4 + i] !== bgPixel[i]) {\n                  grid[gx][gy] = false;\n                  break singleGridLoop;\n                }\n              }\n            }\n          }\n\n          if (grid[gx][gy] !== false) {\n            grid[gx][gy] = true;\n          }\n        }\n      }\n\n      imageData = bctx = bgPixel = undefined;\n    } // fill the infoGrid with empty state if we need it\n\n\n    if (settings.hover || settings.click) {\n      interactive = true;\n      /* fill the grid with empty state */\n\n      gx = ngx + 1;\n\n      while (gx--) {\n        infoGrid[gx] = [];\n      }\n\n      if (settings.hover) {\n        canvas.addEventListener('mousemove', wordcloudhover);\n      }\n\n      var touchend = function (e) {\n        e.preventDefault();\n      };\n\n      if (settings.click) {\n        canvas.addEventListener('click', wordcloudclick);\n        canvas.addEventListener('touchstart', wordcloudclick);\n        canvas.addEventListener('touchend', touchend);\n        canvas.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)';\n      }\n\n      canvas.addEventListener('wordcloudstart', function stopInteraction() {\n        canvas.removeEventListener('wordcloudstart', stopInteraction);\n        canvas.removeEventListener('mousemove', wordcloudhover);\n        canvas.removeEventListener('click', wordcloudclick);\n        canvas.removeEventListener('touchstart', wordcloudclick);\n        canvas.removeEventListener('touchend', touchend);\n        hovered = undefined;\n      });\n    }\n\n    i = 0;\n    var loopingFunction, stoppingFunction;\n\n    if (settings.wait !== 0) {\n      loopingFunction = window.setTimeout;\n      stoppingFunction = window.clearTimeout;\n    } else {\n      loopingFunction = window.setImmediate;\n      stoppingFunction = window.clearImmediate;\n    }\n\n    var addEventListener = function addEventListener(type, listener) {\n      elements.forEach(function (el) {\n        el.addEventListener(type, listener);\n      }, this);\n    };\n\n    var removeEventListener = function removeEventListener(type, listener) {\n      elements.forEach(function (el) {\n        el.removeEventListener(type, listener);\n      }, this);\n    };\n\n    var anotherWordCloudStart = function anotherWordCloudStart() {\n      removeEventListener('wordcloudstart', anotherWordCloudStart);\n      stoppingFunction(timer);\n    };\n\n    addEventListener('wordcloudstart', anotherWordCloudStart);\n    var timer = loopingFunction(function loop() {\n      if (i >= settings.list.length) {\n        stoppingFunction(timer);\n        sendEvent('wordcloudstop', false);\n        removeEventListener('wordcloudstart', anotherWordCloudStart);\n        return;\n      }\n\n      escapeTime = new Date().getTime();\n      var putWordParam = {\n        item: settings.list[i],\n        index: i\n      };\n\n      if (settings.frame && settings.frame.length === settings.list.length) {\n        putWordParam.frame = settings.frame[i];\n      }\n\n      var drawn = putWord(putWordParam);\n      var canceled = !sendEvent('wordclouddrawn', true, {\n        item: settings.list[i],\n        drawn: drawn\n      });\n\n      if (exceedTime() || canceled) {\n        stoppingFunction(timer);\n        settings.abort();\n        sendEvent('wordcloudabort', false);\n        sendEvent('wordcloudstop', false);\n        removeEventListener('wordcloudstart', anotherWordCloudStart);\n        return;\n      }\n\n      i++;\n      timer = loopingFunction(loop, settings.wait);\n    }, settings.wait); // START END\n  }; // All set, start the drawing\n\n\n  start(); // WORDCLOUD END\n};\n\nWordCloud.isSupported = isSupported;\nWordCloud.minFontSize = minFontSize;\nexport default WordCloud; // Expose the library as an AMD module\n// if (typeof define === 'function' && define.amd) {\n//   global.WordCloud = WordCloud;\n//   define('wordcloud', [], function() { return WordCloud; });\n// } else if (typeof module !== 'undefined' && module.exports) {\n//   module.exports = WordCloud;\n// } else {\n//   global.WordCloud = WordCloud;\n// }","map":{"version":3,"sources":["/Users/amiel.suarez/Desktop/Micmic/Lungs/src/wordcloud2.js"],"names":["window","setImmediate","setupSetImmediate","msSetImmediate","webkitSetImmediate","mozSetImmediate","oSetImmediate","setupSetZeroTimeout","postMessage","addEventListener","callbacks","undefined","message","setZeroTimeout","callback","id","length","push","toString","setZeroTimeoutMessage","evt","data","substr","stopImmediatePropagation","parseInt","clearImmediate","clearZeroTimeout","setImmediateFallback","fn","setTimeout","setupClearImmediate","msClearImmediate","webkitClearImmediate","mozClearImmediate","oClearImmediate","clearImmediateFallback","timer","clearTimeout","isSupported","canvas","document","createElement","getContext","ctx","getImageData","fillText","Array","prototype","some","minFontSize","getMinFontSize","size","hanWidth","mWidth","font","measureText","width","shuffleArray","arr","j","x","i","Math","floor","random","WordCloud","elements","options","isArray","forEach","el","getElementById","Error","tagName","appendChild","settings","list","frame","fontFamily","fontWeight","color","minSize","weightFactor","clearCanvas","backgroundColor","gridSize","drawOutOfBound","origin","drawMask","maskColor","maskGapWidth","wait","abortThreshold","abort","noop","minRotation","PI","maxRotation","rotationSteps","shuffle","rotateRatio","shape","ellipticity","classes","hover","click","key","factor","pt","shapeCardioid","theta","sin","shapeSquare","thetaPrime","cos","min","abs","shapeTriangle","sqrt","shapePentagon","shapeStar","max","g","maskRectWidth","rotationRange","grid","ngx","ngy","center","maxRadius","escapeTime","getTextColor","random_hsl_color","toFixed","getRandomDarkColor","getRandomLightColor","getTextFontWeight","getTextClasses","interactive","infoGrid","hovered","getInfoGridFromMouseTouchEvent","currentTarget","rect","getBoundingClientRect","clientX","clientY","touches","eventX","left","eventY","top","y","height","wordcloudhover","info","item","dimension","wordcloudclick","preventDefault","pointsAtRadius","getPointsAtRadius","radius","T","t","points","rx","exceedTime","Date","getTime","getRotateDeg","index","getTextInfo","word","weight","rotateDeg","debug","fontSize","mu","calculateScaleFactor","fcanvas","fctx","willReadFrequently","fw","fh","boxWidth","boxHeight","fgw","ceil","fgh","fillTextOffsetX","fillTextOffsetY","cgh","cgw","setAttribute","body","save","scale","translate","rotate","fillStyle","textBaseline","imageData","strokeRect","restore","occupied","gx","gy","bounds","fillRect","gw","gh","fillTextWidth","fillTextHeight","canFitText","px","py","drawText","textInfo","text","distance","attributes","w","h","scaleX","translateX","translateY","moveX","adjustX","span","transformRule","styleRules","textContent","cssProp","style","attribute","className","fillGridAt","updateGrid","putWord","params","raw","r","tryToPutWordAtPoint","gxy","concat","drawn","sendEvent","type","cancelable","details","event","CustomEvent","detail","dispatchEvent","start","clearRect","position","bctx","bgPixel","singleGridLoop","touchend","e","webkitTapHighlightColor","stopInteraction","removeEventListener","loopingFunction","stoppingFunction","listener","anotherWordCloudStart","loop","putWordParam","canceled"],"mappings":"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","sourcesContent":["/*!\n* wordcloud2.js\n* http://timdream.org/wordcloud2.js/\n*\n* Copyright 2011 - 2013 Tim Chien\n* Released under the MIT license\n*/\n\n\n\n\n// setImmediate\nif (!window.setImmediate) {\n  window.setImmediate = (function setupSetImmediate() {\n    return window.msSetImmediate ||\n    window.webkitSetImmediate ||\n    window.mozSetImmediate ||\n    window.oSetImmediate ||\n    (function setupSetZeroTimeout() {\n      if (!window.postMessage || !window.addEventListener) {\n        return null;\n      }\n\n      var callbacks = [undefined];\n      var message = 'zero-timeout-message';\n\n      // Like setTimeout, but only takes a function argument.  There's\n      // no time argument (always zero) and no arguments (you have to\n      // use a closure).\n      var setZeroTimeout = function setZeroTimeout(callback) {\n        var id = callbacks.length;\n        callbacks.push(callback);\n        window.postMessage(message + id.toString(36), '*');\n\n        return id;\n      };\n\n      window.addEventListener('message', function setZeroTimeoutMessage(evt) {\n        // Skipping checking event source, retarded IE confused this window\n        // object with another in the presence of iframe\n        if (typeof evt.data !== 'string' ||\n            evt.data.substr(0, message.length) !== message/* ||\n            evt.source !== window */) {\n          return;\n        }\n\n        evt.stopImmediatePropagation();\n\n        var id = parseInt(evt.data.substr(message.length), 36);\n        if (!callbacks[id]) {\n          return;\n        }\n\n        callbacks[id]();\n        callbacks[id] = undefined;\n      }, true);\n\n      /* specify clearImmediate() here since we need the scope */\n      window.clearImmediate = function clearZeroTimeout(id) {\n        if (!callbacks[id]) {\n          return;\n        }\n\n        callbacks[id] = undefined;\n      };\n\n      return setZeroTimeout;\n    })() ||\n    // fallback\n    function setImmediateFallback(fn) {\n      window.setTimeout(fn, 0);\n    };\n  })();\n}\n\nif (!window.clearImmediate) {\nwindow.clearImmediate = (function setupClearImmediate() {\n  return window.msClearImmediate ||\n  window.webkitClearImmediate ||\n  window.mozClearImmediate ||\n  window.oClearImmediate ||\n  // \"clearZeroTimeout\" is implement on the previous block ||\n  // fallback\n  function clearImmediateFallback(timer) {\n    window.clearTimeout(timer);\n  };\n})();\n}\n\n\n\n// Check if WordCloud can run on this browser\nvar isSupported = (function isSupported() {\n  var canvas = document.createElement('canvas');\n  if (!canvas || !canvas.getContext) {\n    return false;\n  }\n\n  var ctx = canvas.getContext('2d');\n  if (!ctx) {\n    return false;\n  }\n  if (!ctx.getImageData) {\n    return false;\n  }\n  if (!ctx.fillText) {\n    return false;\n  }\n\n  if (!Array.prototype.some) {\n    return false;\n  }\n  if (!Array.prototype.push) {\n    return false;\n  }\n\n  return true;\n}());\n\n// Find out if the browser impose minium font size by\n// drawing small texts on a canvas and measure it's width.\nvar minFontSize = (function getMinFontSize() {\n  if (!isSupported) {\n    return;\n  }\n\n  var ctx = document.createElement('canvas').getContext('2d');\n\n  // start from 20\n  var size = 20;\n\n  // two sizes to measure\n  var hanWidth, mWidth;\n\n  while (size) {\n    ctx.font = size.toString(10) + 'px sans-serif';\n    if ((ctx.measureText('\\uFF37').width === hanWidth) &&\n        (ctx.measureText('m').width) === mWidth) {\n      return (size + 1);\n    }\n\n    hanWidth = ctx.measureText('\\uFF37').width;\n    mWidth = ctx.measureText('m').width;\n\n    size--;\n  }\n\n  return 0;\n})();\n\n// Based on http://jsfromhell.com/array/shuffle\nvar shuffleArray = function shuffleArray(arr) {\n  for (var j, x, i = arr.length; i;\n    j = Math.floor(Math.random() * i),\n    x = arr[--i], arr[i] = arr[j],\n    arr[j] = x) {}\n  return arr;\n};\n\nvar WordCloud = function WordCloud(elements, options) {\n  if (!isSupported) {\n    return;\n  }\n\n  if (!Array.isArray(elements)) {\n    elements = [elements];\n  }\n\n  elements.forEach(function(el, i) {\n    if (typeof el === 'string') {\n      elements[i] = document.getElementById(el);\n      if (!elements[i]) {\n        throw new Error('The element id specified is not found.');\n      }\n    } else if (!el.tagName && !el.appendChild) {\n      throw new Error('You must pass valid HTML elements, or ID of the element.');\n    }\n  });\n\n  /* Default values to be overwritten by options object */\n  var settings = {\n    list: [],\n    frame: null,\n    fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"微軟正黑體\", ' +\n                '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',\n    fontWeight: 'normal',\n    color: 'random-dark',\n    minSize: 0, // 0 to disable\n    weightFactor: 1,\n    clearCanvas: true,\n    backgroundColor: '#fff',  // opaque white = rgba(255, 255, 255, 1)\n\n    gridSize: 8,\n    drawOutOfBound: false,\n    origin: null,\n\n    drawMask: false,\n    maskColor: 'rgba(255,0,0,0.3)',\n    maskGapWidth: 0.3,\n\n    wait: 0,\n    abortThreshold: 0, // disabled\n    abort: function noop() {},\n\n    minRotation: - Math.PI / 2,\n    maxRotation: Math.PI / 2,\n    rotationSteps: 0,\n\n    shuffle: true,\n    rotateRatio: 0.1,\n\n    shape: 'circle',\n    ellipticity: 0.65,\n\n    classes: null,\n\n    hover: null,\n    click: null\n  };\n\n  if (options) {\n    for (var key in options) {\n      if (key in settings) {\n        settings[key] = options[key];\n      }\n    }\n  }\n\n  /* Convert weightFactor into a function */\n  if (typeof settings.weightFactor !== 'function') {\n    var factor = settings.weightFactor;\n    settings.weightFactor = function weightFactor(pt) {\n      return pt * factor; //in px\n    };\n  }\n\n  /* Convert shape into a function */\n  if (typeof settings.shape !== 'function') {\n    switch (settings.shape) {\n      case 'circle':\n      /* falls through */\n      default:\n        // 'circle' is the default and a shortcut in the code loop.\n        settings.shape = 'circle';\n        break;\n\n      case 'cardioid':\n        settings.shape = function shapeCardioid(theta) {\n          return 1 - Math.sin(theta);\n        };\n        break;\n\n      /*\n\n      To work out an X-gon, one has to calculate \"m\",\n      where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))\n      http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28\n      2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29\n\n      Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))\n      where t' equals to mod(t, 2PI/X);\n\n      */\n\n      case 'diamond':\n        // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n        // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D\n        // +0+..+2*PI\n        settings.shape = function shapeSquare(theta) {\n          var thetaPrime = theta % (2 * Math.PI / 4);\n          return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));\n        };\n        break;\n\n      case 'square':\n        // http://www.wolframalpha.com/input/?i=plot+r+%3D+min(1%2Fabs(cos(t\n        // )),1%2Fabs(sin(t)))),+t+%3D+0+..+2*PI\n        settings.shape = function shapeSquare(theta) {\n          return Math.min(\n            1 / Math.abs(Math.cos(theta)),\n            1 / Math.abs(Math.sin(theta))\n          );\n        };\n        break;\n\n      case 'triangle-forward':\n        // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n        // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29\n        // %29%29%2C+t+%3D+0+..+2*PI\n        settings.shape = function shapeTriangle(theta) {\n          var thetaPrime = theta % (2 * Math.PI / 3);\n          return 1 / (Math.cos(thetaPrime) +\n                      Math.sqrt(3) * Math.sin(thetaPrime));\n        };\n        break;\n\n      case 'triangle':\n      case 'triangle-upright':\n        settings.shape = function shapeTriangle(theta) {\n          var thetaPrime = (theta + Math.PI * 3 / 2) % (2 * Math.PI / 3);\n          return 1 / (Math.cos(thetaPrime) +\n                      Math.sqrt(3) * Math.sin(thetaPrime));\n        };\n        break;\n\n      case 'pentagon':\n        settings.shape = function shapePentagon(theta) {\n          var thetaPrime = (theta + 0.955) % (2 * Math.PI / 5);\n          return 1 / (Math.cos(thetaPrime) +\n                      0.726543 * Math.sin(thetaPrime));\n        };\n        break;\n\n      case 'star':\n        settings.shape = function shapeStar(theta) {\n          var thetaPrime = (theta + 0.955) % (2 * Math.PI / 10);\n          if ((theta + 0.955) % (2 * Math.PI / 5) - (2 * Math.PI / 10) >= 0) {\n            return 1 / (Math.cos((2 * Math.PI / 10) - thetaPrime) +\n                        3.07768 * Math.sin((2 * Math.PI / 10) - thetaPrime));\n          } else {\n            return 1 / (Math.cos(thetaPrime) +\n                        3.07768 * Math.sin(thetaPrime));\n          }\n        };\n        break;\n    }\n  }\n\n  /* Make sure gridSize is a whole number and is not smaller than 4px */\n  settings.gridSize = Math.max(Math.floor(settings.gridSize), 4);\n\n  /* shorthand */\n  var g = settings.gridSize;\n  var maskRectWidth = g - settings.maskGapWidth;\n\n  /* normalize rotation settings */\n  var rotationRange = Math.abs(settings.maxRotation - settings.minRotation);\n  var rotationSteps = Math.abs(Math.floor(settings.rotationSteps));\n  var minRotation = Math.min(settings.maxRotation, settings.minRotation);\n\n  /* information/object available to all functions, set when start() */\n  var grid, // 2d array containing filling information\n    ngx, ngy, // width and height of the grid\n    center, // position of the center of the cloud\n    maxRadius;\n\n  /* timestamp for measuring each putWord() action */\n  var escapeTime;\n\n  /* function for getting the color of the text */\n  var getTextColor;\n  function random_hsl_color(min, max) {\n    return 'hsl(' +\n      (Math.random() * 360).toFixed() + ',' +\n      (Math.random() * 30 + 70).toFixed() + '%,' +\n      (Math.random() * (max - min) + min).toFixed() + '%)';\n  }\n  switch (settings.color) {\n    case 'random-dark':\n      getTextColor = function getRandomDarkColor() {\n        return random_hsl_color(10, 50);\n      };\n      break;\n\n    case 'random-light':\n      getTextColor = function getRandomLightColor() {\n        return random_hsl_color(50, 90);\n      };\n      break;\n\n    default:\n      if (typeof settings.color === 'function') {\n        getTextColor = settings.color;\n      }\n      break;\n  }\n\n  /* function for getting the font-weight of the text */\n  var getTextFontWeight;\n  if (typeof settings.fontWeight === 'function') {\n    getTextFontWeight = settings.fontWeight;\n  }\n\n  /* function for getting the classes of the text */\n  var getTextClasses = null;\n  if (typeof settings.classes === 'function') {\n    getTextClasses = settings.classes;\n  }\n\n  /* Interactive */\n  var interactive = false;\n  var infoGrid = [];\n  var hovered;\n\n  var getInfoGridFromMouseTouchEvent =\n  function getInfoGridFromMouseTouchEvent(evt) {\n    var canvas = evt.currentTarget;\n    var rect = canvas.getBoundingClientRect();\n    var clientX;\n    var clientY;\n    /** Detect if touches are available */\n    if (evt.touches) {\n      clientX = evt.touches[0].clientX;\n      clientY = evt.touches[0].clientY;\n    } else {\n      clientX = evt.clientX;\n      clientY = evt.clientY;\n    }\n    var eventX = clientX - rect.left;\n    var eventY = clientY - rect.top;\n\n    var x = Math.floor(eventX * ((canvas.width / rect.width) || 1) / g);\n    var y = Math.floor(eventY * ((canvas.height / rect.height) || 1) / g);\n\n    return infoGrid[x][y];\n  };\n\n  var wordcloudhover = function wordcloudhover(evt) {\n    var info = getInfoGridFromMouseTouchEvent(evt);\n\n    if (hovered === info) {\n      return;\n    }\n\n    hovered = info;\n    if (!info) {\n      settings.hover(undefined, undefined, evt);\n\n      return;\n    }\n\n    settings.hover(info.item, info.dimension, evt);\n\n  };\n\n  var wordcloudclick = function wordcloudclick(evt) {\n    var info = getInfoGridFromMouseTouchEvent(evt);\n    if (!info) {\n      return;\n    }\n\n    settings.click(info.item, info.dimension, evt);\n    evt.preventDefault();\n  };\n\n  /* Get points on the grid for a given radius away from the center */\n  var pointsAtRadius = [];\n  var getPointsAtRadius = function getPointsAtRadius(radius) {\n    if (pointsAtRadius[radius]) {\n      return pointsAtRadius[radius];\n    }\n\n    // Look for these number of points on each radius\n    var T = radius * 8;\n\n    // Getting all the points at this radius\n    var t = T;\n    var points = [];\n\n    if (radius === 0) {\n      points.push([center[0], center[1], 0]);\n    }\n\n    while (t--) {\n      // distort the radius to put the cloud in shape\n      var rx = 1;\n      if (settings.shape !== 'circle') {\n        rx = settings.shape(t / T * 2 * Math.PI); // 0 to 1\n      }\n\n      // Push [x, y, t]; t is used solely for getTextColor()\n      points.push([\n        center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI),\n        center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) *\n          settings.ellipticity,\n        t / T * 2 * Math.PI]);\n    }\n\n    pointsAtRadius[radius] = points;\n    return points;\n  };\n\n  /* Return true if we had spent too much time */\n  var exceedTime = function exceedTime() {\n    return ((settings.abortThreshold > 0) &&\n      ((new Date()).getTime() - escapeTime > settings.abortThreshold));\n  };\n\n  /* Get the deg of rotation according to settings, and luck. */\n  var getRotateDeg = function getRotateDeg(index) {\n    if (settings.rotateRatio === 0) {\n      return 0;\n    }\n\n    if (settings.shuffle){\n      if (Math.random() > settings.rotateRatio) {\n        return 0;\n      }\n    } else {\n      if (index % 2) {\n        return 0;\n      }\n    }\n    \n\n    if (rotationRange === 0) {\n      return minRotation;\n    }\n\n    if (rotationSteps > 0) {\n      // Min rotation + zero or more steps * span of one step\n      if (settings.shuffle){\n        return minRotation + Math.floor(Math.random() * rotationSteps) * rotationRange / (rotationSteps - 1);\n      } else {\n        return minRotation + Math.floor((index % 2) * rotationSteps) * rotationRange / (rotationSteps - 1);\n      }\n    }\n    else {\n      return minRotation + Math.random() * rotationRange;\n    }\n  };\n\n  var getTextInfo = function getTextInfo(word, weight, rotateDeg) {\n    // calculate the acutal font size\n    // fontSize === 0 means weightFactor function wants the text skipped,\n    // and size < minSize means we cannot draw the text.\n    var debug = false;\n    var fontSize = settings.weightFactor(weight);\n    if (fontSize <= settings.minSize) {\n      return false;\n    }\n\n    // Scale factor here is to make sure fillText is not limited by\n    // the minium font size set by browser.\n    // It will always be 1 or 2n.\n    var mu = 1;\n    if (fontSize < minFontSize) {\n      mu = (function calculateScaleFactor() {\n        var mu = 2;\n        while (mu * fontSize < minFontSize) {\n          mu += 2;\n        }\n        return mu;\n      })();\n    }\n\n    // Get fontWeight that will be used to set fctx.font\n    var fontWeight;\n    if (getTextFontWeight) {\n      fontWeight = getTextFontWeight(word, weight, fontSize);\n    } else {\n      fontWeight = settings.fontWeight;\n    }\n\n    var fcanvas = document.createElement('canvas');\n    var fctx = fcanvas.getContext('2d', { willReadFrequently: true });\n\n    fctx.font = fontWeight + ' ' +\n      (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n\n    // Estimate the dimension of the text with measureText().\n    var fw = fctx.measureText(word).width / mu;\n    var fh = Math.max(fontSize * mu,\n                      fctx.measureText('m').width,\n                      fctx.measureText('\\uFF37').width) / mu;\n\n    // Create a boundary box that is larger than our estimates,\n    // so text don't get cut of (it sill might)\n    var boxWidth = fw + fh * 2;\n    var boxHeight = fh * 3;\n    var fgw = Math.ceil(boxWidth / g);\n    var fgh = Math.ceil(boxHeight / g);\n    boxWidth = fgw * g;\n    boxHeight = fgh * g;\n\n    // Calculate the proper offsets to make the text centered at\n    // the preferred position.\n\n    // This is simply half of the width.\n    var fillTextOffsetX = - fw / 2;\n    // Instead of moving the box to the exact middle of the preferred\n    // position, for Y-offset we move 0.4 instead, so Latin alphabets look\n    // vertical centered.\n    var fillTextOffsetY = - fh * 0.4;\n\n    // Calculate the actual dimension of the canvas, considering the rotation.\n    var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) +\n                          boxHeight * Math.abs(Math.cos(rotateDeg))) / g);\n    var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) +\n                          boxHeight * Math.abs(Math.sin(rotateDeg))) / g);\n    var width = cgw * g;\n    var height = cgh * g;\n\n    fcanvas.setAttribute('width', width);\n    fcanvas.setAttribute('height', height);\n\n    if (debug) {\n      // Attach fcanvas to the DOM\n      document.body.appendChild(fcanvas);\n      // Save it's state so that we could restore and draw the grid correctly.\n      fctx.save();\n    }\n\n    // Scale the canvas with |mu|.\n    fctx.scale(1 / mu, 1 / mu);\n    fctx.translate(width * mu / 2, height * mu / 2);\n    fctx.rotate(- rotateDeg);\n\n    // Once the width/height is set, ctx info will be reset.\n    // Set it again here.\n    fctx.font = fontWeight + ' ' +\n      (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n\n    // Fill the text into the fcanvas.\n    // XXX: We cannot because textBaseline = 'top' here because\n    // Firefox and Chrome uses different default line-height for canvas.\n    // Please read https://bugzil.la/737852#c6.\n    // Here, we use textBaseline = 'middle' and draw the text at exactly\n    // 0.5 * fontSize lower.\n    fctx.fillStyle = '#000';\n    fctx.textBaseline = 'middle';\n    fctx.fillText(word, fillTextOffsetX * mu,\n                  (fillTextOffsetY + fontSize * 0.5) * mu);\n\n    // Get the pixels of the text\n    var imageData = fctx.getImageData(0, 0, width, height).data;\n\n    if (exceedTime()) {\n      return false;\n    }\n\n    if (debug) {\n      // Draw the box of the original estimation\n      fctx.strokeRect(fillTextOffsetX * mu,\n                      fillTextOffsetY, fw * mu, fh * mu);\n      fctx.restore();\n    }\n\n    // Read the pixels and save the information to the occupied array\n    var occupied = [];\n    var gx = cgw, gy, x, y;\n    var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];\n    while (gx--) {\n      gy = cgh;\n      while (gy--) {\n        y = g;\n      \n          while (y--) {\n            x = g;\n            while (x--) {\n              if (imageData[((gy * g + y) * width +\n                              (gx * g + x)) * 4 + 3]) {\n                occupied.push([gx, gy]);\n\n                if (gx < bounds[3]) {\n                  bounds[3] = gx;\n                }\n                if (gx > bounds[1]) {\n                  bounds[1] = gx;\n                }\n                if (gy < bounds[0]) {\n                  bounds[0] = gy;\n                }\n                if (gy > bounds[2]) {\n                  bounds[2] = gy;\n                }\n\n                if (debug) {\n                  fctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n                  fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n                }\n                break;\n              }\n            }\n          }\n          if (debug) {\n            fctx.fillStyle = 'rgba(0, 0, 255, 0.5)';\n            fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n          }\n    \n      }\n    }\n\n    if (debug) {\n      fctx.fillStyle = 'rgba(0, 255, 0, 0.5)';\n      fctx.fillRect(bounds[3] * g,\n                    bounds[0] * g,\n                    (bounds[1] - bounds[3] + 1) * g,\n                    (bounds[2] - bounds[0] + 1) * g);\n    }\n\n    // Return information needed to create the text on the real canvas\n    return {\n      mu: mu,\n      occupied: occupied,\n      bounds: bounds,\n      gw: cgw,\n      gh: cgh,\n      fillTextOffsetX: fillTextOffsetX,\n      fillTextOffsetY: fillTextOffsetY,\n      fillTextWidth: fw,\n      fillTextHeight: fh,\n      fontSize: fontSize\n    };\n  };\n\n  /* Determine if there is room available in the given dimension */\n  var canFitText = function canFitText(gx, gy, gw, gh, occupied) {\n    // Go through the occupied points,\n    // return false if the space is not available.\n    var i = occupied.length;\n    while (i--) {\n      var px = gx + occupied[i][0];\n      var py = gy + occupied[i][1];\n\n      if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n        if (!settings.drawOutOfBound) {\n          return false;\n        }\n        continue;\n      }\n\n      if (!grid[px][py]) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n  /* Actually draw the text on the grid */\n  var drawText = function drawText(gx, gy, info, textInfo, text, weight, distance, theta, rotateDeg, attributes) {\n\n    var fontSize = info.fontSize;\n    var color;\n    if (getTextColor) {\n      color = getTextColor(text, weight, fontSize, distance, theta);\n    } else {\n      color = settings.color;\n    }\n\n    // get fontWeight that will be used to set ctx.font and font style rule\n    var fontWeight;\n    if (getTextFontWeight) {\n      fontWeight = getTextFontWeight(text, weight, fontSize);\n    } else {\n      fontWeight = settings.fontWeight;\n    }\n\n    var classes;\n    if (getTextClasses) {\n      classes = getTextClasses(text, weight, fontSize);\n    } else {\n      classes = settings.classes;\n    }\n\n    var dimension;\n    var bounds = info.bounds;\n    dimension = {\n      x: (gx + bounds[3]) * g,\n      y: (gy + bounds[0]) * g,\n      w: (bounds[1] - bounds[3] + 1) * g,\n      h: (bounds[2] - bounds[0] + 1) * g\n    };\n\n    elements.forEach(function(el) {\n      if (el.getContext) {\n        var ctx = el.getContext('2d');\n        var mu = info.mu;\n\n        // Save the current state before messing it\n        ctx.save();\n        // SCALE_TEXT\n\n      \n\n        var scaleX = info.fillTextWidth / textInfo.fillTextWidth;\n        if (rotateDeg !== 0) {\n          ctx.scale(1 / mu, scaleX / mu, );\n        } else {\n          ctx.scale(scaleX / mu, 1 / mu);\n        }\n        \n\n        ctx.font = fontWeight + ' ' + (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n        ctx.fillStyle = color;\n\n        // Translate the canvas position to the origin coordinate of where\n        // the text should be put.\n\n        \n        \n        var translateX = (gx + info.gw / 2) * g * mu;\n        var translateY = (gy + info.gh / 2) * g * mu;\n\n        \n        var moveX = scaleX;\n        var adjustX = 0;\n        if (moveX !== 1){\n            moveX = scaleX \n            adjustX = info.fillTextOffsetX - textInfo.fillTextOffsetX\n        }\n\n        if (rotateDeg !== 0) {\n          ctx.translate(translateX, translateY/moveX - adjustX);\n          ctx.rotate(- rotateDeg);\n        } else {\n          ctx.translate(translateX/moveX - adjustX, translateY);\n        }\n\n        // Finally, fill the text.\n\n        // XXX: We cannot because textBaseline = 'top' here because\n        // Firefox and Chrome uses different default line-height for canvas.\n        // Please read https://bugzil.la/737852#c6.\n        // Here, we use textBaseline = 'middle' and draw the text at exactly\n        // 0.5 * fontSize lower.\n        ctx.textBaseline = 'middle';\n        ctx.fillText(text, info.fillTextOffsetX * mu,\n                            (info.fillTextOffsetY + fontSize * 0.5) * mu);\n\n        // The below box is always matches how <span>s are positioned\n        /* ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,\n          info.fillTextWidth, info.fillTextHeight); */\n\n        // Restore the state.\n        ctx.restore();\n      } else {\n        // drawText on DIV element\n        var span = document.createElement('span');\n        var transformRule = '';\n        transformRule = 'rotate(' + (- rotateDeg / Math.PI * 180) + 'deg) ';\n        if (info.mu !== 1) {\n          transformRule +=\n            'translateX(-' + (info.fillTextWidth / 4) + 'px) ' +\n            'scale(' + (1 / info.mu) + ')';\n        }\n        var styleRules = {\n          'position': 'absolute',\n          'display': 'block',\n          'font': fontWeight + ' ' +\n                  (fontSize * info.mu) + 'px ' + settings.fontFamily,\n          'left': ((gx + info.gw / 2) * g + info.fillTextOffsetX) + 'px',\n          'top': ((gy + info.gh / 2) * g + info.fillTextOffsetY) + 'px',\n          'width': info.fillTextWidth + 'px',\n          'height': info.fillTextHeight + 'px',\n          'lineHeight': fontSize + 'px',\n          'whiteSpace': 'nowrap',\n          'transform': transformRule,\n          'webkitTransform': transformRule,\n          'msTransform': transformRule,\n          'transformOrigin': '50% 40%',\n          'webkitTransformOrigin': '50% 40%',\n          'msTransformOrigin': '50% 40%'\n        };\n        if (color) {\n          styleRules.color = color;\n        }\n        span.textContent = text;\n        for (var cssProp in styleRules) {\n          span.style[cssProp] = styleRules[cssProp];\n        }\n        if (attributes) {\n          for (var attribute in attributes) {\n            span.setAttribute(attribute, attributes[attribute]);\n          }\n        }\n        if (classes) {\n          span.className += classes;\n        }\n        el.appendChild(span);\n      }\n    });\n  };\n\n  /* Help function to updateGrid */\n  var fillGridAt = function fillGridAt(x, y, drawMask, dimension, item) {\n    if (x >= ngx || y >= ngy || x < 0 || y < 0) {\n      return;\n    }\n\n    grid[x][y] = false;\n\n    if (drawMask) {\n      var ctx = elements[0].getContext('2d');\n      ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth);\n    }\n\n    if (interactive) {\n      infoGrid[x][y] = { item: item, dimension: dimension };\n    }\n  };\n\n  /* Update the filling information of the given space with occupied points.\n      Draw the mask on the canvas if necessary. */\n  var updateGrid = function updateGrid(gx, gy, gw, gh, info, item) {\n    var occupied = info.occupied;\n    var drawMask = settings.drawMask;\n    var ctx;\n    if (drawMask) {\n      ctx = elements[0].getContext('2d');\n      ctx.save();\n      ctx.fillStyle = settings.maskColor;\n    }\n\n    var dimension;\n    if (interactive) {\n      var bounds = info.bounds;\n      dimension = {\n        x: (gx + bounds[3]) * g,\n        y: (gy + bounds[0]) * g,\n        w: (bounds[1] - bounds[3] + 1) * g,\n        h: (bounds[2] - bounds[0] + 1) * g\n      };\n    }\n\n    var i = occupied.length;\n    while (i--) {\n      var px = gx + occupied[i][0];\n      var py = gy + occupied[i][1];\n\n      if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n        continue;\n      }\n\n      fillGridAt(px, py, drawMask, dimension, item);\n    }\n\n    if (drawMask) {\n      ctx.restore();\n    }\n  };\n\n  /* putWord() processes each item on the list,\n      calculate it's size and determine it's position, and actually\n      put it on the canvas. */\n  var putWord = function putWord(params) {\n    var {index, item, frame} = params;\n    var word, text, weight, attributes;\n\n    var raw = frame || item;\n\n    if (Array.isArray(raw)) {\n      word = raw[0];\n      weight = raw[1];\n      text = item[0];\n    } else {\n      word = raw.word;\n      text = item.word\n      weight = raw.weight;\n      attributes = raw.attributes;\n    }\n    \n    var rotateDeg = getRotateDeg(index);\n\n    // get info needed to put the text onto the canvas\n    var info = getTextInfo(word, weight, rotateDeg);\n    var textInfo = getTextInfo(text, weight, rotateDeg);\n\n    // not getting the info means we shouldn't be drawing this one.\n    if (!info) {\n      return false;\n    }\n\n    if (exceedTime()) {\n      return false;\n    }\n\n    // If drawOutOfBound is set to false,\n    // skip the loop if we have already know the bounding box of\n    // word is larger than the canvas.\n    if (!settings.drawOutOfBound) {\n      var bounds = info.bounds;\n      if ((bounds[1] - bounds[3] + 1) > ngx ||\n        (bounds[2] - bounds[0] + 1) > ngy) {\n        return false;\n      }\n    }\n\n    // Determine the position to put the text by\n    // start looking for the nearest points\n    var r = maxRadius + 1;\n\n    var tryToPutWordAtPoint = function(gxy) {\n      var gx = Math.floor(gxy[0] - info.gw / 2);\n      var gy = Math.floor(gxy[1] - info.gh / 2);\n      var gw = info.gw;\n      var gh = info.gh;\n\n      // If we cannot fit the text at this position, return false\n      // and go to the next position.\n      if (!canFitText(gx, gy, gw, gh, info.occupied)) {\n        return false;\n      }\n\n      // Actually put the text on the canvas\n      drawText(gx, gy, info, textInfo, text, weight,(maxRadius - r), gxy[2], rotateDeg, attributes);\n\n      // Mark the spaces on the grid as filled\n      updateGrid(gx, gy, gw, gh, info, item);\n\n      // Return true so some() will stop and also return true.\n      return true;\n    };\n\n    while (r--) {\n      var points = getPointsAtRadius(maxRadius - r);\n    \n      if (settings.shuffle) {\n        points = [].concat(points);\n        shuffleArray(points);\n      }\n\n      // Try to fit the words by looking at each point.\n      // array.some() will stop and return true\n      // when putWordAtPoint() returns true.\n      // If all the points returns false, array.some() returns false.\n      var drawn = points.some(tryToPutWordAtPoint);\n\n      if (drawn) {\n        // leave putWord() and return true\n        return true;\n      }\n    }\n    // we tried all distances but text won't fit, return false\n    return false;\n  };\n\n  /* Send DOM event to all elements. Will stop sending event and return\n      if the previous one is canceled (for cancelable events). */\n  var sendEvent = function sendEvent(type, cancelable, details) {\n    if (cancelable) {\n      return !elements.some(function(el) {\n        var event = new CustomEvent(type, {\n          detail: details || {}\n        });\n        return !el.dispatchEvent(event);\n      }, this);\n    } else {\n      elements.forEach(function(el) {\n        var event = new CustomEvent(type, {\n          detail: details || {}\n        });\n        el.dispatchEvent(event);\n      }, this);\n    }\n  };\n\n  /* Start drawing on a canvas */\n  var start = function start() {\n    // For dimensions, clearCanvas etc.,\n    // we only care about the first element.\n    var canvas = elements[0];\n\n    if (canvas.getContext) {\n      ngx = Math.ceil(canvas.width / g);\n      ngy = Math.ceil(canvas.height / g);\n    } else {\n      var rect = canvas.getBoundingClientRect();\n      ngx = Math.ceil(rect.width / g);\n      ngy = Math.ceil(rect.height / g);\n    }\n\n    // Sending a wordcloudstart event which cause the previous loop to stop.\n    // Do nothing if the event is canceled.\n    if (!sendEvent('wordcloudstart', true)) {\n      return;\n    }\n\n    // Determine the center of the word cloud\n    center = (settings.origin) ?\n      [settings.origin[0]/g, settings.origin[1]/g] :\n      [ngx / 2, ngy / 2];\n\n    // Maxium radius to look for space\n    maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));\n\n    /* Clear the canvas only if the clearCanvas is set,\n        if not, update the grid to the current canvas state */\n    grid = [];\n\n    var gx, gy, i;\n    if (!canvas.getContext || settings.clearCanvas) {\n      elements.forEach(function(el) {\n        if (el.getContext) {\n          var ctx = el.getContext('2d');\n          ctx.fillStyle = settings.backgroundColor;\n          ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n          ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n        } else {\n          el.textContent = '';\n          el.style.backgroundColor = settings.backgroundColor;\n          el.style.position = 'relative';\n        }\n      });\n\n      /* fill the grid with empty state */\n      gx = ngx;\n      while (gx--) {\n        grid[gx] = [];\n        gy = ngy;\n        while (gy--) {\n          grid[gx][gy] = true;\n        }\n      }\n    } else {\n      /* Determine bgPixel by creating\n          another canvas and fill the specified background color. */\n      var bctx = document.createElement('canvas').getContext('2d');\n\n      bctx.fillStyle = settings.backgroundColor;\n      bctx.fillRect(0, 0, 1, 1);\n      var bgPixel = bctx.getImageData(0, 0, 1, 1).data;\n\n      /* Read back the pixels of the canvas we got to tell which part of the\n          canvas is empty.\n          (no clearCanvas only works with a canvas, not divs) */\n      var imageData =\n        canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data;\n\n      gx = ngx;\n      var x, y;\n      while (gx--) {\n        grid[gx] = [];\n        gy = ngy;\n        while (gy--) {\n          y = g;\n          singleGridLoop: while (y--) {\n            x = g;\n            while (x--) {\n              i = 4;\n              while (i--) {\n                if (imageData[((gy * g + y) * ngx * g +\n                                (gx * g + x)) * 4 + i] !== bgPixel[i]) {\n                  grid[gx][gy] = false;\n                  break singleGridLoop;\n                }\n              }\n            }\n          }\n          if (grid[gx][gy] !== false) {\n            grid[gx][gy] = true;\n          }\n        }\n      }\n\n      imageData = bctx = bgPixel = undefined;\n    }\n\n    // fill the infoGrid with empty state if we need it\n    if (settings.hover || settings.click) {\n\n      interactive = true;\n\n      /* fill the grid with empty state */\n      gx = ngx + 1;\n      while (gx--) {\n        infoGrid[gx] = [];\n      }\n\n      if (settings.hover) {\n        canvas.addEventListener('mousemove', wordcloudhover);\n      }\n\n      var touchend = function (e) {\n        e.preventDefault();\n      };\n\n      if (settings.click) {\n        canvas.addEventListener('click', wordcloudclick);\n        canvas.addEventListener('touchstart', wordcloudclick);\n        canvas.addEventListener('touchend', touchend);\n        canvas.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)';\n      }\n\n      canvas.addEventListener('wordcloudstart', function stopInteraction() {\n        canvas.removeEventListener('wordcloudstart', stopInteraction);\n\n        canvas.removeEventListener('mousemove', wordcloudhover);\n        canvas.removeEventListener('click', wordcloudclick);\n        canvas.removeEventListener('touchstart', wordcloudclick);\n        canvas.removeEventListener('touchend', touchend);\n        hovered = undefined;\n      });\n    }\n\n    i = 0;\n    var loopingFunction, stoppingFunction;\n    if (settings.wait !== 0) {\n      loopingFunction = window.setTimeout;\n      stoppingFunction = window.clearTimeout;\n    } else {\n      loopingFunction = window.setImmediate;\n      stoppingFunction = window.clearImmediate;\n    }\n\n    var addEventListener = function addEventListener(type, listener) {\n      elements.forEach(function(el) {\n        el.addEventListener(type, listener);\n      }, this);\n    };\n\n    var removeEventListener = function removeEventListener(type, listener) {\n      elements.forEach(function(el) {\n        el.removeEventListener(type, listener);\n      }, this);\n    };\n\n    var anotherWordCloudStart = function anotherWordCloudStart() {\n      removeEventListener('wordcloudstart', anotherWordCloudStart);\n      stoppingFunction(timer);\n    };\n\n    addEventListener('wordcloudstart', anotherWordCloudStart);\n\n    var timer = loopingFunction(function loop() {\n      if (i >= settings.list.length) {\n        stoppingFunction(timer);\n        sendEvent('wordcloudstop', false);\n        removeEventListener('wordcloudstart', anotherWordCloudStart);\n\n        return;\n      }\n      escapeTime = (new Date()).getTime();\n\n      var putWordParam = {\n        item: settings.list[i], \n        index: i\n      }\n\n      if (settings.frame && settings.frame.length === settings.list.length){\n        putWordParam.frame = settings.frame[i];\n      }\n\n      var drawn = putWord(putWordParam);\n      var canceled = !sendEvent('wordclouddrawn', true, {\n        item: settings.list[i], drawn: drawn });\n      if (exceedTime() || canceled) {\n        stoppingFunction(timer);\n        settings.abort();\n        sendEvent('wordcloudabort', false);\n        sendEvent('wordcloudstop', false);\n        removeEventListener('wordcloudstart', anotherWordCloudStart);\n        return;\n      }\n      i++;\n      timer = loopingFunction(loop, settings.wait);\n    }, settings.wait);\n    \n    // START END\n  };\n\n  // All set, start the drawing\n  start();\n  \n  // WORDCLOUD END\n};\n\nWordCloud.isSupported = isSupported;\nWordCloud.minFontSize = minFontSize;\n\nexport default WordCloud;\n\n// Expose the library as an AMD module\n// if (typeof define === 'function' && define.amd) {\n//   global.WordCloud = WordCloud;\n//   define('wordcloud', [], function() { return WordCloud; });\n// } else if (typeof module !== 'undefined' && module.exports) {\n//   module.exports = WordCloud;\n// } else {\n//   global.WordCloud = WordCloud;\n// }\n"]},"metadata":{},"sourceType":"module"}